<html>
<head>
 <title>Grades Report - Student View</title>
 <style>
	table#overall{
		width:100%;
	}
	table#overall td{
		width:100%;position:relative;background-color:rgba(0,0,255,0.5);text-align:center;color:white;text-shadow:0 0 2px black;
	}
	table#overall div{
		position:absolute;
		z-index:-1;
		top:0;
		left:0;
		height:100%;
		width:0%;
		background-color:green;
	}
 </style>
 <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/4.11.0/d3.min.js" integrity="sha256-aYYnqVVhAJ4lDammP4Qybmxg3/HVpA7/sNSCntyCyu4=" crossorigin="anonymous"></script>
 <script language="javascript" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/pouchdb/5.3.1/pouchdb.min.js"></script>
 <script language="javascript" type="text/javascript" src="https://cdn.rawgit.com/pouchdb/upsert/master/dist/pouchdb.upsert.min.js"></script>
 
 <script>
	'use strict';
	JSON.clone = JSON.clone || function(json){
		json = JSON.stringify(json);
		json = JSON.parse(json);
		return json;
	}
	
	var constants = {
		KeyDelim: '.',
		today: (new Date()).toISOString().substr(0,10),
	}
	
	var app = {
		KeyDelim: constants.KeyDelim,
		docsDiffer: function(oldDoc, newDoc){
			oldDoc = JSON.clone(oldDoc);
			newDoc = JSON.clone(newDoc);
			
			for(let field in oldDoc){
				if(field.substr(0,1) === '_'){
					delete oldDoc[field];
				}
			}
			for(let field in newDoc){
				if(field.substr(0,1) === '_'){
					delete newDoc[field];
				}
			}
			
			oldDoc = JSON.stringify(oldDoc);
			newDoc = JSON.stringify(newDoc);
			
			rtn = (oldDoc !== newDoc);
			return rtn;
		},
		parseDate: d3.timeParse("%Y-%m-%d"),
		formatDate: d3.timeFormat("%Y-%m-%d"),

	};
	
 </script>

 <script src="data.js"></script>
 
 <script>
	var db = new PouchDB('grades',{
		auto_compaction: false, 
		//adapter:'websql',
	});
	db.on('error', function (err) { debugger; });
	//db.destroy();
	var remoteCouch = false;
	
	db.upsert('_design/metrics',function(oldDoc){
		console.debug('Generating database views...');
		var newDoc = {};
		newDoc.views = {
			'grades': {
				map: function(doc) {
					// determine if the object belongs in this listing
					if (!doc) return;
					if (doc.isConfig) return;
					if (doc.isExcused) return;
					
					var key = doc._id.split(app.KeyDelim);
					if(key[0] !== 'grade') return;
					key.shift();
					
//					doc.grade.pct = doc.grade.grade/doc.grade.of;
//					doc.weight.grade = doc.grade.pct * doc.weight.of;
					
					
					emit(key,{
						grade: doc.weight.grade || 0,
						of: doc.weight.of,
//						pct: doc.weighted.grade / doc.weighted.of,
					});
				}.toString()
				,reduce: function(keys, values, rereduce) {
					grade = 0;
					of = 0;
					count = 0;
					values.forEach(function(rec){
						grade += rec.grade;
						of += rec.of;
						count += rec.count || 1;
					});
					return {
						grade: grade,
						of:    of,
						pct:   grade/of,
						count: count
					};
				}.toString()
			},
			'gradesByDate': {
				map: function(doc) {
					// determine if the object belongs in this listing
					if (!doc) return;
					if (doc.isConfig) return;
					if (doc.isExcused) return;
					
					var key = doc._id.split(app.KeyDelim);
					if(key[0] !== 'grade') return;
					key.shift();
					// move the date from the end to the start
					let classId = key.shift();
					let studentId = key.shift();
					let gradeDate = key.pop();
					key.unshift(gradeDate);
					key.unshift(studentId);
					key.unshift(classId);
					
					emit(key,{
						grade: doc.weight.grade || 0,
						of: doc.weight.of,
					});
				}.toString()
				,reduce: function(keys, values, rereduce) {
					grade = 0;
					of = 0;
					count = 0;
					values.forEach(function(rec){
						grade += rec.grade;
						of += rec.of;
						count += rec.count || 1;
					});
					return {
						grade: grade,
						of:    of,
						pct:   grade/of,
						count: count
					};
				}.toString()
			}
		};
		
		if(!app.docsDiffer(oldDoc,newDoc)) {
			console.log('metrics calculations: current');
			return false;
		}
		console.log('metrics calculations: rebuilding (change detected)');
		return newDoc;
				
	}).then(function(){
	
		/**
		* Import my data
		*/
		gradeData.forEach(function(rec){
			let key = ["grade","logprog",rec.student,rec.cat,rec.item,rec.date].join(app.KeyDelim);
			db.upsert(key, function(doc){
				rec.grade.grade = rec.grade.grade || 0;
				rec.grade.pct = rec.grade.pct || 0;
				rec.weight.grade = rec.weight.grade || 0;
				if(rec.grade.of){
					rec.grade.pct = rec.grade.grade / rec.grade.of;
					rec.weight.grade = rec.grade.pct * rec.weight.of;
				}
				if(app.docsDiffer(doc,rec)){
					rec._id = key;
					return rec;
				}
				return false;
			}).then(function(rec){
				//console.log(JSON.stringify(rec));
			}).catch(function(err){
				console.log(JSON.stringify(err));
			});
		});
	}).catch(function(err){
		console.log(err.message);
	});
</script>
</head>
<body>

<select>
 <option value="W0000000">Joel, Billy</option>
 <option value="W0000001">Hutch, Starsky</option>
 <option value="W0000002">Young, Angus</option>
</select>

<h1>Joel, Billy</h1>
<p>W000000</p>
<details>
 <summary>
  <table id="overall">
   <caption></caption>
   <tbody>
    <tr>
     <td><div style="width:50%;"></div>Course Progress (10 of 20 days)</td>
    </tr>
    <tr>
     <td><div style='width:40%;'></div>Grades (40% of Total Grades)</td>
    </tr>
   </tbody>
  </table>
 </summary>
</details>

<details id="studentgrades" open>
 <summary>Grades (97%)</summary>
 <!--script>
	'use strict';
	(function(){
		let opts = {
			include_docs:true,
			reduce:false,
			//group:true,
			//group_level:3,
			startkey:null,
			endkey:{},
		};
		db.query('metrics/gradesByDate', opts)
			.then( function(result){
				
				console.debug(result);
				// alright... time to start rendering it
				let table = d3.select("#studentgrades").append("table");
				let thead = table.append("thead");
				let tbody = table.append("tbody");
				
				// append the header row
				let head = Object
					.keys(result.rows.reduce(function(a,d){
						a[d.doc.cat] = null;
						return a;
					},{}))
					.sort()
					;
				head.unshift("Total");
				head.unshift("");
				thead.append("tr")
					.selectAll("th")
					.data(head)
					.enter()
						.append("th")
						.text((column)=>{ return column; })
						;
				
				if(result.rows.length < 1) return;
				
				let cummulative = result.rows.reduce(function(a,d){
					a[d.doc.date] = a[d.doc.date] || {
						vals:{},
						date:d.doc.date,
						total:JSON.parse(JSON.stringify(d.value))
					};
					let rec = a[d.doc.date];
					rec.vals[d.doc.cat] = rec.vals[d.doc.cat] || {grade:0,of:0};
					rec.vals[d.doc.cat].grade += d.value.grade || 0;
					rec.vals[d.doc.cat].of += d.value.of || 0;
					return a;
				},{});
				cummulative = Object.keys(cummulative)
					.map(function(d){
						return cummulative[d];
					})
					.sort(function(a,b){
						a = parseInt(a.date.replace(/[^0-9]/g,''));
						b = parseInt(b.date.replace(/[^0-9]/g,''));
						rtn = a-b;
						return rtn;
					})
					;
				
				// create a row for each object in the data
				var rows = tbody.selectAll("tr")
					.data(cummulative)
					.enter()
					.append("tr")
					;
				
				rows.selectAll("th")
					.data(function(d){
						let pct = Math.floor(100.0 * d.total.grade / d.total.of);
						pct = Number.isNaN(pct) ? 0 : pct;
						let rtn = "{{achieved}}% of {{possible}}% ({{pct}}%)"
							.replace(/{{achieved}}/g,Math.floor(d.total.grade * 100))
							.replace(/{{possible}}/g,Math.floor(d.total.of * 100))
							.replace(/{{pct}}/g,pct)
							;
						return [
							d.date,
							rtn
						];
					})
					.enter()
						.append("th")
						.text(function(d){
							return d;
						})
					;
				
				head.shift();
				head.shift();
				var cells = rows.selectAll('td')
					.data(function (row) {
						return head
							.splice(0)
							.map(function(d){
								return row.vals[d] || {grade:0,of:0};
							})
							;
					})
					.enter()
						.append('td')
						.text(function (d) {
							let pct = Math.floor(100.0 * d.grade / d.of);
							pct = Number.isNaN(pct) ? 0 : pct;
							let rtn = "{{achieved}} of {{possible}} ({{pct}})"
								.replace(/{{achieved}}/g,Math.floor(d.grade * 100))
								.replace(/{{possible}}/g,Math.floor(d.of * 100))
								.replace(/{{pct}}/g, pct)
							return rtn;
						})
						;
				console.log("HERE");
			})
			.catch(function(err){
				console.log(err);
			});
	})();	
 </script-->
 <script>
	'use strict';
	(function(){
		let opts = {
			group:true,
			group_level:3,
			startkey:null,
			endkey:{},
		};
		db.query('metrics/gradesByDate', opts)
			.then( function(result){
				var projections = [];
				result.rows = result.rows.reduce(function(a,d){
					d = JSON.clone(d);
					if(a.length === 0){ 
						return [d];
					}
					
					let last = a[a.length-1];
					d.value.of += last.value.of;
					// either calulcate the grade they have acheived
					if(constants.today > d.key[2]){
						d.value.grade += last.value.grade || 0;
						d.value.pct = d.value.grade / d.value.of;
					}
					// or calcluate their projected grade
					else{
						d.value.pct = last.value.pct;
						d.value.grade = last.value.grade;
						if(!projections.length){
							projections.unshift({
								date: constants.today,
								possible: last.value.grade,
								avg: last.value.grade,
								pct: d.value.pct,
							});
						}
						projections.unshift({
							date: d.key[2],
							possible: projections[0].possible + (d.value.of - last.value.of),
							avg: projections[0].pct * d.value.of,
							pct: projections[0].pct,
						});
					}
					
					let enddate = app.parseDate(last.key[2]);
					let fill = [];
					for(let date = app.parseDate(d.key[2]); date > enddate; date.setDate(date.getDate()-1)){
						d.key[2] = app.formatDate(date);
						fill.push(JSON.clone(d));
					}
					
					while(fill.length > 0){
						a.push(fill.pop());
					}
					return a;
				},[]);
				projections.reverse();
				console.log(result);
				console.log(projections);
				
				// Set the dimensions of the canvas / graph
				var margin = {top: 30, right: 50, bottom: 30, left: 20};
				var width = 600 - margin.left - margin.right;
				var height = 270 - margin.top - margin.bottom;
				
				// Set the ranges
				var x = d3.scaleTime().range([0, width]);
				var y = d3.scaleLinear().range([height, 0]);
				// Scale the range of the data
				x.domain(d3.extent(result.rows, function(d) { return app.parseDate(d.key[2]); }));
				y.domain([0, 1]);
				
				
				// Define the axes
				var xAxis = d3.axisBottom().scale(x).ticks(5);
				var yAxis = d3.axisRight().scale(y).ticks(5);
				
				// Define the line
				var lineOf = d3.line()
					.curve(d3.curveStepBefore)
					.x(function(d) { 
						d = app.parseDate(d.key[2]); 
						return x(d)
					})
					.y(function(d) { 
						return y(d.value.of); 
					})
					;
				var lineGrade = d3.line()
					.curve(d3.curveStepBefore)
					.x(function(d) { 
						d = app.parseDate(d.key[2]); 
						return x(d); 
					})
					.y(function(d) { return y(d.value.grade); })
					;
				var linePossible = d3.line()
					.curve(d3.curveCatmullRom)
					.x(function(d) {
						d = app.parseDate(d.date); 
						d = x(d)
						return d; 
					})
					.y(function(d) {
						d = d.possible;
						d = y(d);
						return d;
					})
					;
				var lineExpected = d3.line()
					.curve(d3.curveCatmullRom)
					.x(function(d) {
						d = app.parseDate(d.date); 
						d = x(d)
						return d; 
					})
					.y(function(d) {
						d = d.avg;
						d = y(d);
						return d;
					})
					;
				
				// Adds the svg canvas
				var svg = d3.select("#studentgrades")
					.append("svg")
						.attr("width", width + margin.left + margin.right)
						.attr("height", height + margin.top + margin.bottom)
					.append("g")
						.attr("transform","translate(" + margin.left + "," + margin.top + ")")
					;
				
				// Add the valueline path.
				svg.append("path")
					.attr("fill", "none")
					.attr("stroke", "black")
					.attr("d", lineOf(result.rows))
					;
				svg.append("path")
					.attr("fill", "none")
					.attr("stroke", "steelblue")
					.attr("d", lineGrade(result.rows))
					;
				
				
				// Add the X Axis
				svg.append("g")
					.attr("class", "x axis")
					.attr("transform", "translate(0," + height + ")")
					.call(xAxis)
					;
				
				// Add the Y Axis
				svg.append("g")
					.attr("class", "y axis")
					.attr("transform", "translate("+width+",0)")
					.call(yAxis)
					;
				
				// Today Line
				let xToday = x(app.parseDate(constants.today));
/*				
				var marker = svg.append('g').attr('id','today').append('path')
					.attr("stroke", "red")
					.attr("stroke-width", 3)
					.attr("fill","red")
					.attr('opacity',0)
					.attr('d', ['M0,0 Q ',xToday,',',0,' ',xToday,',0 Q ',xToday,',0 ',width,',0'].join(''))
					;
				marker
					.transition().duration(1000)
						.attr('opacity', 1)
						.attr('d', ['M',xToday,',0 Q ',xToday,',',0,' ',xToday,',',height,' Q ',xToday,',',0,' ',xToday,',0'].join(''))
					;
*/
				var todayMarker = svg.append('g').attr('id','today').append('path')
					.attr("stroke", "red")
					.attr("stroke-width", 3)
					.attr("fill","red")
					.attr('opacity',0)
					.attr('d', ['M',0,',',height,' Q ',xToday,',',height,' ',xToday,',',height,' Q ',xToday,',',height,' ',width,',',height].join(''))
					.transition()
						.delay(100)
						.duration(1000)
						.attr('opacity', 1)
						.attr('d', ['M',xToday,',',height,' Q ',xToday,',',height,' ',xToday,',',0,' Q ',xToday,',',height,' ',xToday,',',height].join(''))
					;
				
				var gradeVals = projections.map((d)=>{
					return projections[0];
				});
				var randVals = projections.map((d,i)=>{
					d = JSON.clone(d);
					d.possible = (!i)?d.possible:Math.random();
					return d;
				});
				var accordianVals = projections.map((d,i)=>{
					d = JSON.clone(d);
					d.date = projections[0].date;
					d.possible = i%2;
					return d;
				});
				svg.append("path")
					.attr("fill", "none")
					.attr("stroke", "green")
					.attr('opacity',0)
					.attr("d", linePossible(accordianVals))
					.transition()
						//wait for todayMarker to get drawn in
						.delay(1200)
						.duration(1)
						.attr('opacity',1)
					.transition()
						.duration(500)
						.attr("d", linePossible(randVals))
					.transition()
						.duration(1000)
						.ease(d3.easeElasticOut)
						.attr("d", linePossible(projections))
					;
				svg.append("path")
					.attr("fill", "none")
					.attr("stroke", "green")
					.attr('opacity',0)
					.attr("d", linePossible(projections))
					.transition()
						// wait for possible line to finish
						.delay(2700)
						.duration(1)
						.attr('opacity',1)
					.transition()
						.duration(500)
						.ease(d3.easeElasticInOut)
						.attr("d", lineExpected(projections))
					;
			})
			.catch(function(err){
				console.log(err);
			});
	})();	
 </script>
 <style>
	details#studentgrades table{
		border:1px solid black;
		border-collapse: collapse;
		font-family:monospace;
		font-size:0.75em;
		
	}
	details#studentgrades td,th{
		border:1px solid black;
		padding: 0.5em;
	}
	/*
	details#studentgrades th{
		background-color:black;
		color:white;
	}
	*/
 </style>
</details>

<details>
 <summary>Attendance</summary>
 <table>
  <tr>
   <td></td>
  </tr>
 </table>
</details>


</body>
</html>
